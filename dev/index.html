<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Manual · CherenkovDeconvolution.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">CherenkovDeconvolution.jl</span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Manual</a><ul class="internal"><li><a class="tocitem" href="#Getting-started"><span>Getting started</span></a></li><li><a class="tocitem" href="#Adaptive-stepsizes-in-DSEA"><span>Adaptive stepsizes in DSEA+</span></a></li><li><a class="tocitem" href="#Inspection-of-intermediate-results"><span>Inspection of intermediate results</span></a></li><li><a class="tocitem" href="#Improving-performance-by-pre-fitting"><span>Improving performance by pre-fitting</span></a></li></ul></li><li><a class="tocitem" href="developer-manual/">Developer manual</a></li><li><a class="tocitem" href="python-wrapper/">Python wrapper</a></li><li><a class="tocitem" href="api-reference/">API reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Manual</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Manual</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/mirkobunse/CherenkovDeconvolution.jl/blob/master/docs/src/index.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Manual"><a class="docs-heading-anchor" href="#Manual">CherenkovDeconvolution.jl</a><a id="Manual-1"></a><a class="docs-heading-anchor-permalink" href="#Manual" title="Permalink"></a></h1><p>Deconvolution problems arise when the probability density function of a quantity is estimated even though this quantity cannot be measured directly. In this scenario, the density has to be inferred from related quantities which are measured instead.</p><h2 id="Getting-started"><a class="docs-heading-anchor" href="#Getting-started">Getting started</a><a id="Getting-started-1"></a><a class="docs-heading-anchor-permalink" href="#Getting-started" title="Permalink"></a></h2><p>CherenkovDeconvolution.jl can be installed through the Julia package manager. From the Julia REPL, type <code>]</code> to enter the Pkg mode of the REPL. Then run</p><pre><code class="language-none">pkg&gt; add CherenkovDeconvolution</code></pre><p>To deconvolve an observed unlabeled data set <code>X_obs</code>, you need to configure the deconvolution method and to provide a labeled data set <code>(X_trn, y_trn)</code> for training. For instance, you can apply the <em>DSEA+</em> algorithm with a naive Bayes classifier from <a href="https://github.com/cstjean/ScikitLearn.jl">ScikitLearn.jl</a> as follows:</p><pre><code class="language-julia">using CherenkovDeconvolution, ScikitLearn
@sk_import naive_bayes : GaussianNB

m = DSEA(GaussianNB())
f_dsea = deconvolve(m, X_obs, X_trn, y_trn)</code></pre><p>Classical deconvolution methods require a binning object to discretize the features in <code>X_obs</code> and <code>X_trn</code> into a single discrete dimension; in fact, this discretization is nothing but a clustering.</p><pre><code class="language-julia">m = RUN(TreeBinning(10)) # use up to 10 clusters
f_run = deconvolve(m, X_obs, X_trn, y_trn)</code></pre><p>You can choose to cluster prediction scores of a classifier instead of clustering the features. Clustering these scores with a <a href="api-reference/#CherenkovDeconvolution.Binnings.KMeansBinning"><code>KMeansBinning</code></a> can be beneficial if you already know a well-performing classifier for your data which is not a decision tree.</p><pre><code class="language-julia">@sk_import linear_model : LogisticRegression

clf = LogisticRegression()
m = RUN(KMeansBinning(10, ClassificationPreprocessor(clf)))
f_run_clf = deconvolve(m, X_obs, X_trn, y_trn)</code></pre><p>As you can see, all deconvolution methods are executed in the same way, through a call to the <code>deconvolve</code> function. Their configuration is further documented in the <a href="api-reference/#API-reference">API reference</a>.</p><h2 id="Adaptive-stepsizes-in-DSEA"><a class="docs-heading-anchor" href="#Adaptive-stepsizes-in-DSEA">Adaptive stepsizes in DSEA+</a><a id="Adaptive-stepsizes-in-DSEA-1"></a><a class="docs-heading-anchor-permalink" href="#Adaptive-stepsizes-in-DSEA" title="Permalink"></a></h2><p>DSEA+ extends the original DSEA with an adaptively chosen stepsize between iterations. Here, both versions of DSEA are implemented as the same deconvolution method, <a href="api-reference/#CherenkovDeconvolution.Methods.DSEA"><code>DSEA</code></a>, and only differ in their configuration. By default, a constant step size of one is used, but through the <code>stepsize</code> argument, we can easily specify adaptive stepsizes.</p><p>The most important one, <a href="api-reference/#CherenkovDeconvolution.OptimizedStepsizes.RunStepsize"><code>RunStepsize</code></a>, uses the objective function of <a href="api-reference/#CherenkovDeconvolution.Methods.RUN"><code>RUN</code></a> to determine the step size adaptively. In the following example, <code>epsilon</code> specifies the minimum Chi square distance between iterations; convergence is assumed if the distance drops below this threshold.</p><pre><code class="language-julia">stepsize = RunStepsize(TreeBinning(10); decay=true)
dsea = DSEA(GaussianNB(); K=100, epsilon=1e-6, stepsize=stepsize)
f_dsea = deconvolve(dsea, X_data, X_train, y_train)</code></pre><p>Another adaptive step size, based on a least-square objective, is the <a href="api-reference/#CherenkovDeconvolution.OptimizedStepsizes.LsqStepsize"><code>LsqStepsize</code></a>. Two decaying step sizes are implemented in <a href="api-reference/#CherenkovDeconvolution.Stepsizes.ExpDecayStepsize"><code>ExpDecayStepsize</code></a> and <a href="api-reference/#CherenkovDeconvolution.Stepsizes.MulDecayStepsize"><code>MulDecayStepsize</code></a>. The <a href="api-reference/#CherenkovDeconvolution.Stepsizes.DEFAULT_STEPSIZE"><code>DEFAULT_STEPSIZE</code></a> for all methods is a <a href="api-reference/#CherenkovDeconvolution.Stepsizes.ConstantStepsize"><code>ConstantStepsize</code></a> of one.</p><h2 id="Inspection-of-intermediate-results"><a class="docs-heading-anchor" href="#Inspection-of-intermediate-results">Inspection of intermediate results</a><a id="Inspection-of-intermediate-results-1"></a><a class="docs-heading-anchor-permalink" href="#Inspection-of-intermediate-results" title="Permalink"></a></h2><p>Iterative algorithms like DSEA, IBU, and RUN allow you to inspect their intermediate results of each iteration through the keyword argument <code>inspect</code>. This argument accept a <code>Function</code> object, which will be called in each iteration of the deconvolution algorithm. Depending on the algorithm, this <code>Function</code> object must have one of several signatures.</p><p>For <a href="api-reference/#CherenkovDeconvolution.Methods.DSEA"><code>DSEA</code></a> and <a href="api-reference/#CherenkovDeconvolution.Methods.IBU"><code>IBU</code></a>, the <code>inspect</code> function has to have the following signature:</p><pre><code class="language-julia">(f_k::Vector, k::Int, chi2s::Float64, alpha::Float64) -&gt; Any</code></pre><p>You do not have to stick to the argument names (<code>f_k</code>, <code>k</code>, etc) and you do not even have to specify the types of the arguments explicitly. However, these are the types that the parameters will have, so do not expect anything else. The return value of the <code>inspect</code> function is never used, so you can return any value, including <code>nothing</code>.</p><p>The first argument of <code>inspect</code>, <code>f_k</code>, refers to the intermediate result of the <code>k</code>-th iteration. <code>chi2s</code> is the Chi-Square distance between <code>f_k</code> and the previous estimate. This distance may be used to check convergence. <code>alpha</code> is the step size used in the <code>k</code>-th iteration.</p><p>The <code>inspect</code> signatures of <a href="api-reference/#CherenkovDeconvolution.Methods.RUN"><code>RUN</code></a> and <a href="api-reference/#CherenkovDeconvolution.Methods.PRUN"><code>PRUN</code></a> are specified in their documentation. They are slightly different but the general inspection mechanism is the same. <a href="api-reference/#CherenkovDeconvolution.Methods.SVD"><code>SVD</code></a> does not have an inspection mechanism because this method only performs a single iteration.</p><p>In the following example, we store every piece of information in a <code>DataFrame</code>:</p><pre><code class="language-julia">using DataFrames
df = DataFrame(f=Vector{Float64}[], k=Int[], chi2s=Float64[], a=Float64[])

# append everything to the DataFrame
inspect_function = (f, k, chi2s, a) -&gt; push!(df, [f, k, chi2s, a])
m = DSEA(
    GaussianNB();
    K = 3,
    inspect = inspect_function
)

deconvolve(m, X_obs, X_trn, y_trn) # start the deconvolution</code></pre><h2 id="Improving-performance-by-pre-fitting"><a class="docs-heading-anchor" href="#Improving-performance-by-pre-fitting">Improving performance by pre-fitting</a><a id="Improving-performance-by-pre-fitting-1"></a><a class="docs-heading-anchor-permalink" href="#Improving-performance-by-pre-fitting" title="Permalink"></a></h2><p>Computing the <a href="api-reference.html#Binnings">Binnings</a> for the discrete deconvolution methods typically takes a considerable amount of time. You can speed up the deconvolution of multiple observations <code>X_obs_1, X_obs_2, ...</code> by computing these binnings only once with <a href="api-reference/#CherenkovDeconvolution.Methods.prefit"><code>prefit</code></a>:</p><pre><code class="language-julia">m = RUN(TreeBinning(10))
m_prefit = prefit(m, X_trn, y_trn) # a fitted copy; m remains unchanged!
f_1 = deconvolve(m_prefit, X_obs_1)
f_2 = deconvolve(m_prefit, X_obs_2)
...</code></pre></article><nav class="docs-footer"><a class="docs-footer-nextpage" href="developer-manual/">Developer manual »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Thursday 5 January 2023 11:06">Thursday 5 January 2023</span>. Using Julia version 1.8.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
