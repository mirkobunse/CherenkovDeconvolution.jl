<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API reference · CherenkovDeconvolution.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">CherenkovDeconvolution.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Manual</a></li><li><a class="tocitem" href="../developer-manual/">Developer manual</a></li><li><a class="tocitem" href="../python-wrapper/">Python wrapper</a></li><li class="is-active"><a class="tocitem" href>API reference</a><ul class="internal"><li><a class="tocitem" href="#Deconvolution-methods"><span>Deconvolution methods</span></a></li><li><a class="tocitem" href="#Binnings"><span>Binnings</span></a></li><li><a class="tocitem" href="#Stepsizes"><span>Stepsizes</span></a></li><li><a class="tocitem" href="#DeconvUtil"><span>DeconvUtil</span></a></li><li><a class="tocitem" href="#Developer-interface"><span>Developer interface</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API reference</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/mirkobunse/CherenkovDeconvolution.jl/blob/master/docs/src/api-reference.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="API-reference"><a class="docs-heading-anchor" href="#API-reference">API reference</a><a id="API-reference-1"></a><a class="docs-heading-anchor-permalink" href="#API-reference" title="Permalink"></a></h1><p>The following is a list of all public methods in CherenkovDeconvolution.jl.</p><h2 id="Deconvolution-methods"><a class="docs-heading-anchor" href="#Deconvolution-methods">Deconvolution methods</a><a id="Deconvolution-methods-1"></a><a class="docs-heading-anchor-permalink" href="#Deconvolution-methods" title="Permalink"></a></h2><p>All deconvolution methods implement the <a href="#CherenkovDeconvolution.Methods.deconvolve"><code>deconvolve</code></a> function.</p><article class="docstring"><header><a class="docstring-binding" id="CherenkovDeconvolution.Methods.deconvolve" href="#CherenkovDeconvolution.Methods.deconvolve"><code>CherenkovDeconvolution.Methods.deconvolve</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">deconvolve(m, X_obs, X_trn, y_trn)</code></pre><p>Deconvolve the observed features in <code>X_obs</code> with the deconvolution method <code>m</code> trained on the features <code>X_trn</code> and the corresponding labels <code>y_trn</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mirkobunse/CherenkovDeconvolution.jl/blob/71dc855f841469b3438695912d46fe3f82b80784/src/Methods.jl#L79-L84">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CherenkovDeconvolution.Methods.DSEA" href="#CherenkovDeconvolution.Methods.DSEA"><code>CherenkovDeconvolution.Methods.DSEA</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">DSEA(classifier; kwargs...)</code></pre><p>The <em>DSEA/DSEA+</em> deconvolution method, embedding the given <code>classifier</code>.</p><p><strong>Keyword arguments</strong></p><ul><li><code>f_0 = ones(m) ./ m</code> defines the prior, which is uniform by default</li><li><code>fixweighting = true</code> sets, whether or not the weight update fix is applied. This fix is proposed in my Master&#39;s thesis and in the corresponding paper.</li><li><code>stepsize = DEFAULT_STEPSIZE</code> is the step size taken in every iteration.</li><li><code>smoothing = Base.identity</code> is a function that optionally applies smoothing in between iterations.</li><li><code>K = 1</code> is the maximum number of iterations.</li><li><code>epsilon = 0.0</code> is the minimum symmetric Chi Square distance between iterations. If the actual distance is below this threshold, convergence is assumed and the algorithm stops.</li><li><code>inspect = nothing</code> is a function <code>(f_k::Vector, k::Int, chi2s::Float64, alpha_k::Float64) -&gt; Any</code> optionally called in every iteration.</li><li><code>return_contributions = false</code> sets, whether or not the contributions of individual examples in <code>X_obs</code> are returned as a tuple together with the deconvolution result.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mirkobunse/CherenkovDeconvolution.jl/blob/71dc855f841469b3438695912d46fe3f82b80784/src/methods/dsea.jl#L24-L51">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CherenkovDeconvolution.Methods.IBU" href="#CherenkovDeconvolution.Methods.IBU"><code>CherenkovDeconvolution.Methods.IBU</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">IBU(binning; kwargs...)</code></pre><p>The <em>Iterative Bayesian Unfolding</em> deconvolution method, using a <code>binning</code> to discretize the observable features.</p><p><strong>Keyword arguments</strong></p><ul><li><code>f_0 = ones(m) ./ m</code> defines the prior, which is uniform by default.</li><li><code>smoothing = Base.identity</code> is a function that optionally applies smoothing in between iterations. The operation is neither applied to the initial prior, nor to the final result. The function <code>inspect</code> is called before the smoothing is performed.</li><li><code>K = 3</code> is the maximum number of iterations.</li><li><code>epsilon = 0.0</code> is the minimum symmetric Chi Square distance between iterations. If the actual distance is below this threshold, convergence is assumed and the algorithm stops.</li><li><code>stepsize = DEFAULT_STEPSIZE</code> is the step size taken in every iteration.</li><li><code>inspect = nothing</code> is a function <code>(f_k::Vector, k::Int, chi2s::Float64, alpha_k::Float64) -&gt; Any</code> optionally called in every iteration.</li><li><code>warn = true</code> determines whether warnings about negative values are emitted during normalization.</li><li><code>fit_ratios = false</code> (<strong>discouraged</strong>) determines if ratios are fitted (i.e. <code>R</code> has to contain counts so that the ratio <code>f_est / f_train</code> is estimated) or if the probability density <code>f_est</code> is fitted directly.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mirkobunse/CherenkovDeconvolution.jl/blob/71dc855f841469b3438695912d46fe3f82b80784/src/methods/ibu.jl#L24-L53">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CherenkovDeconvolution.Methods.PRUN" href="#CherenkovDeconvolution.Methods.PRUN"><code>CherenkovDeconvolution.Methods.PRUN</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">PRUN(binning; kwargs...)</code></pre><p>A version of the <em>Regularized Unfolding</em> method that is constrained to positive results. Like the original version, it uses a <code>binning</code> to discretize the observable features.</p><p><strong>Keyword arguments</strong></p><ul><li><code>tau = 0.0</code> determines the regularisation strength.</li><li><code>K = 100</code> is the maximum number of iterations.</li><li><code>epsilon = 1e-6</code> is the minimum difference in the loss function between iterations. RUN stops when the absolute loss difference drops below <code>epsilon</code>.</li><li><code>f_0 = ones(size(R, 2))</code> Starting point for the interior-point Newton optimization.</li><li><code>acceptance_correction = nothing</code>  is a tuple of functions (ac(d), inv<em>ac(d)) representing the acceptance correction ac and its inverse operation inv</em>ac for a data set d.</li><li><code>ac_regularisation = true</code>  decides whether acceptance correction is taken into account for regularisation. Requires <code>acceptance_correction</code> != nothing.</li><li><code>log_constant = 1/18394</code> is a selectable constant used in log regularisation to prevent the undefined case log(0).</li><li><code>inspect = nothing</code> is a function <code>(f_k::Vector, k::Int, ldiff::Float64) -&gt; Any</code> called in each iteration.</li><li><code>warn = true</code> determines whether warnings about negative values are emitted during normalization.</li><li><code>fit_ratios = false</code> (<strong>discouraged</strong>) determines if ratios are fitted (i.e. <code>R</code> has to contain counts so that the ratio <code>f_est / f_train</code> is estimated) or if the probability density <code>f_est</code> is fitted directly.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mirkobunse/CherenkovDeconvolution.jl/blob/71dc855f841469b3438695912d46fe3f82b80784/src/methods/prun.jl#L24-L56">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CherenkovDeconvolution.Methods.RUN" href="#CherenkovDeconvolution.Methods.RUN"><code>CherenkovDeconvolution.Methods.RUN</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">RUN(binning; kwargs...)</code></pre><p>The <em>Regularized Unfolding</em> method, using a <code>binning</code> to discretize the observable features.</p><p><strong>Keyword arguments</strong></p><ul><li><code>n_df = size(R, 2)</code> is the effective number of degrees of freedom. The default <code>n_df</code> results in no regularization (there is one degree of freedom for each dimension in the result).</li><li><code>K = 100</code> is the maximum number of iterations.</li><li><code>epsilon = 1e-6</code> is the minimum difference in the loss function between iterations. RUN stops when the absolute loss difference drops below <code>epsilon</code>.</li><li><code>acceptance_correction = nothing</code>  is a tuple of functions (ac(d), inv<em>ac(d)) representing the acceptance correction ac and its inverse operation inv</em>ac for a data set d.</li><li><code>ac_regularisation = true</code>  decides whether acceptance correction is taken into account for regularisation. Requires <code>acceptance_correction</code> != nothing.</li><li><code>log_constant = 1/18394</code> is a selectable constant used in log regularisation to prevent the undefined case log(0).</li><li><code>inspect = nothing</code> is a function <code>(f_k::Vector, k::Int, ldiff::Float64, tau::Float64) -&gt; Any</code> optionally called in every iteration.</li><li><code>warn = true</code> determines whether warnings about negative values are emitted during normalization.</li><li><code>fit_ratios = false</code> (<strong>discouraged</strong>) determines if ratios are fitted (i.e. <code>R</code> has to contain counts so that the ratio <code>f_est / f_train</code> is estimated) or if the probability density <code>f_est</code> is fitted directly.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mirkobunse/CherenkovDeconvolution.jl/blob/71dc855f841469b3438695912d46fe3f82b80784/src/methods/run.jl#L24-L55">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CherenkovDeconvolution.Methods.SVD" href="#CherenkovDeconvolution.Methods.SVD"><code>CherenkovDeconvolution.Methods.SVD</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">SVD(binning; kwargs...)</code></pre><p>The <em>SVD-based</em> deconvolution method, using a <code>binning</code> to discretize the observable features.</p><p><strong>Keyword arguments</strong></p><ul><li><code>effective_rank = -1</code> is a regularization parameter which defines the effective rank of the solution. This rank must be &lt;= dim(f). Any value smaller than one results turns off regularization.</li><li><code>N = sum(g)</code> is the number of observations.</li><li><code>B = DeconvUtil.cov_Poisson(g, N)</code> is the varianca-covariance matrix of the observed bins. The default value represents the assumption that each observed bin is Poisson-distributed with rate <code>g[i]*N</code>.</li><li><code>epsilon_C = 1e-3</code> is a small constant to be added to each diagonal entry of the regularization matrix <code>C</code>. If no such constant would be added, inversion of <code>C</code> would not be possible.</li><li><code>fit_ratios = true</code> determines if ratios are fitted (i.e. <code>R</code> has to contain counts so that the ratio <code>f_est / f_train</code> is estimated) or if the probability density <code>f_est</code> is fitted directly.</li><li><code>warn = true</code> determines whether warnings about negative values are emitted during normalization.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mirkobunse/CherenkovDeconvolution.jl/blob/71dc855f841469b3438695912d46fe3f82b80784/src/methods/svd.jl#L24-L47">source</a></section></article><h2 id="Binnings"><a class="docs-heading-anchor" href="#Binnings">Binnings</a><a id="Binnings-1"></a><a class="docs-heading-anchor-permalink" href="#Binnings" title="Permalink"></a></h2><p>Binnings are needed by the classical (discrete) deconvolution algorithms, e.g. <a href="#CherenkovDeconvolution.Methods.IBU"><code>IBU</code></a>, <a href="#CherenkovDeconvolution.Methods.PRUN"><code>PRUN</code></a>, <a href="#CherenkovDeconvolution.Methods.RUN"><code>RUN</code></a>, and <a href="#CherenkovDeconvolution.Methods.SVD"><code>SVD</code></a>.</p><article class="docstring"><header><a class="docstring-binding" id="CherenkovDeconvolution.Binnings.TreeBinning" href="#CherenkovDeconvolution.Binnings.TreeBinning"><code>CherenkovDeconvolution.Binnings.TreeBinning</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">TreeBinning(J; kwargs...)</code></pre><p>A supervised tree binning strategy with up to <code>J</code> clusters.</p><p><strong>Keyword arguments</strong></p><ul><li><code>criterion = &quot;gini&quot;</code> is the splitting criterion of the tree.</li><li><code>seed = rand(UInt32)</code> is the random seed for tie breaking.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mirkobunse/CherenkovDeconvolution.jl/blob/71dc855f841469b3438695912d46fe3f82b80784/src/Binnings.jl#L49-L58">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CherenkovDeconvolution.Binnings.KMeansBinning" href="#CherenkovDeconvolution.Binnings.KMeansBinning"><code>CherenkovDeconvolution.Binnings.KMeansBinning</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">KMeansBinning(J; seed=rand(UInt32))</code></pre><p>An unsupervised binning strategy with up to <code>J</code> clusters.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mirkobunse/CherenkovDeconvolution.jl/blob/71dc855f841469b3438695912d46fe3f82b80784/src/Binnings.jl#L70-L74">source</a></section></article><h2 id="Stepsizes"><a class="docs-heading-anchor" href="#Stepsizes">Stepsizes</a><a id="Stepsizes-1"></a><a class="docs-heading-anchor-permalink" href="#Stepsizes" title="Permalink"></a></h2><p>Stepsizes can be used in <a href="#CherenkovDeconvolution.Methods.DSEA"><code>DSEA</code></a> and <a href="#CherenkovDeconvolution.Methods.IBU"><code>IBU</code></a>. Combining the <a href="#CherenkovDeconvolution.OptimizedStepsizes.RunStepsize"><code>RunStepsize</code></a> with <a href="#CherenkovDeconvolution.Methods.DSEA"><code>DSEA</code></a> yields the <em>DSEA+</em> version of the algorithm. More information on stepsizes is given in the <a href="../#Manual">Manual</a>.</p><article class="docstring"><header><a class="docstring-binding" id="CherenkovDeconvolution.OptimizedStepsizes.RunStepsize" href="#CherenkovDeconvolution.OptimizedStepsizes.RunStepsize"><code>CherenkovDeconvolution.OptimizedStepsizes.RunStepsize</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">RunStepsize(binning; kwargs...)</code></pre><p>Adapt the step size by maximizing the likelihood of the next estimate in the search direction of the current iteration, much like in the <code>RUN</code> deconvolution method.</p><p><strong>Keyword arguments:</strong></p><ul><li><code>decay = false</code> specifies whether <code>a_k+1 &lt;= a_k</code> is enforced so that step sizes never increase.</li><li><code>tau = 0.0</code> determines the regularisation strength.</li><li><code>warn = false</code> specifies whether warnings should be emitted for debugging purposes.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mirkobunse/CherenkovDeconvolution.jl/blob/71dc855f841469b3438695912d46fe3f82b80784/src/OptimizedStepsizes.jl#L101-L115">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CherenkovDeconvolution.OptimizedStepsizes.LsqStepsize" href="#CherenkovDeconvolution.OptimizedStepsizes.LsqStepsize"><code>CherenkovDeconvolution.OptimizedStepsizes.LsqStepsize</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">LsqStepsize(binning; kwargs...)</code></pre><p>Adapt the step size by solving a least squares objective in the search direction of the current iteration.</p><p><strong>Keyword arguments:</strong></p><ul><li><code>decay = false</code> specifies whether <code>a_k+1 &lt;= a_k</code> is enforced so that step sizes never increase.</li><li><code>tau = 0.0</code> determines the regularisation strength.</li><li><code>warn = false</code> specifies whether warnings should be emitted for debugging purposes.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mirkobunse/CherenkovDeconvolution.jl/blob/71dc855f841469b3438695912d46fe3f82b80784/src/OptimizedStepsizes.jl#L127-L141">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CherenkovDeconvolution.Stepsizes.ConstantStepsize" href="#CherenkovDeconvolution.Stepsizes.ConstantStepsize"><code>CherenkovDeconvolution.Stepsizes.ConstantStepsize</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ConstantStepsize(alpha)</code></pre><p>Choose the constant step size <code>alpha</code> in every iteration.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mirkobunse/CherenkovDeconvolution.jl/blob/71dc855f841469b3438695912d46fe3f82b80784/src/Stepsizes.jl#L76-L80">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CherenkovDeconvolution.Stepsizes.MulDecayStepsize" href="#CherenkovDeconvolution.Stepsizes.MulDecayStepsize"><code>CherenkovDeconvolution.Stepsizes.MulDecayStepsize</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">MulDecayStepsize(eta, a=1.0)</code></pre><p>Reduce the first stepsize <code>a</code> by <code>eta</code> in each iteration:</p><pre><code class="language-none">value(MulDecayStepsize(eta, a), k, ...) == a * k^(eta-1)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mirkobunse/CherenkovDeconvolution.jl/blob/71dc855f841469b3438695912d46fe3f82b80784/src/Stepsizes.jl#L102-L108">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CherenkovDeconvolution.Stepsizes.ExpDecayStepsize" href="#CherenkovDeconvolution.Stepsizes.ExpDecayStepsize"><code>CherenkovDeconvolution.Stepsizes.ExpDecayStepsize</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ExpDecayStepsize(eta, a=1.0)</code></pre><p>Reduce the first stepsize <code>a</code> by <code>eta</code> in each iteration:</p><pre><code class="language-none">value(ExpDecayStepsize(eta, a), k, ...) == a * eta^(k-1)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mirkobunse/CherenkovDeconvolution.jl/blob/71dc855f841469b3438695912d46fe3f82b80784/src/Stepsizes.jl#L87-L93">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CherenkovDeconvolution.Stepsizes.DEFAULT_STEPSIZE" href="#CherenkovDeconvolution.Stepsizes.DEFAULT_STEPSIZE"><code>CherenkovDeconvolution.Stepsizes.DEFAULT_STEPSIZE</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia">const DEFAULT_STEPSIZE = ConstantStepsize(1.0)</code></pre><p>The default stepsize in all deconvolution methods.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mirkobunse/CherenkovDeconvolution.jl/blob/71dc855f841469b3438695912d46fe3f82b80784/src/Stepsizes.jl#L117-L121">source</a></section></article><h2 id="DeconvUtil"><a class="docs-heading-anchor" href="#DeconvUtil">DeconvUtil</a><a id="DeconvUtil-1"></a><a class="docs-heading-anchor-permalink" href="#DeconvUtil" title="Permalink"></a></h2><p>The module <code>DeconvUtil</code> provides a rich set of user-level ulitity functions. We do not export the members of this module directly, so that you need to name the module when using its functions.</p><pre><code class="language-julia">using CherenkovDeconvolution
fit_pdf([.3, .4, .3]) # WILL BREAK

# solution a)
DeconvUtil.fit_pdf([.3, .4, .3])

# solution b)
import DeconvUtil: fit_pdf
fit_pdf([.3, .4, .3])</code></pre><article class="docstring"><header><a class="docstring-binding" id="CherenkovDeconvolution.DeconvUtil.fit_pdf" href="#CherenkovDeconvolution.DeconvUtil.fit_pdf"><code>CherenkovDeconvolution.DeconvUtil.fit_pdf</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">fit_pdf(x[, bins]; normalize=true, laplace=false)</code></pre><p>Obtain the discrete pdf of the integer array <code>x</code>, optionally specifying the array of <code>bins</code>.</p><p>The result is normalized by default. If it is not normalized now, you can do so later by calling <code>DeconvUtil.normalizepdf</code>.</p><p>Laplace correction means that at least one example is assumed in every bin, so that no bin has probability zero. This feature is disabled by default.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mirkobunse/CherenkovDeconvolution.jl/blob/71dc855f841469b3438695912d46fe3f82b80784/src/DeconvUtil.jl#L44-L55">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CherenkovDeconvolution.DeconvUtil.fit_R" href="#CherenkovDeconvolution.DeconvUtil.fit_R"><code>CherenkovDeconvolution.DeconvUtil.fit_R</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">fit_R(y, x; bins_y, bins_x, normalize=true)</code></pre><p>Estimate the detector response matrix <code>R</code>, which empirically captures the transfer from the integer array <code>y</code> to the integer array <code>x</code>.</p><p><code>R</code> is normalized by default so that <code>fit_pdf(x) == R * fit_pdf(y)</code>. If <code>R</code> is not normalized now, you can do so later calling <code>DeconvUtil.normalizetransfer(R)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mirkobunse/CherenkovDeconvolution.jl/blob/71dc855f841469b3438695912d46fe3f82b80784/src/DeconvUtil.jl#L64-L72">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CherenkovDeconvolution.DeconvUtil.normalizetransfer" href="#CherenkovDeconvolution.DeconvUtil.normalizetransfer"><code>CherenkovDeconvolution.DeconvUtil.normalizetransfer</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">normalizetransfer(R[; warn=true])</code></pre><p>Normalize each column in <code>R</code> to make a probability density function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mirkobunse/CherenkovDeconvolution.jl/blob/71dc855f841469b3438695912d46fe3f82b80784/src/DeconvUtil.jl#L97-L101">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CherenkovDeconvolution.DeconvUtil.normalizepdf" href="#CherenkovDeconvolution.DeconvUtil.normalizepdf"><code>CherenkovDeconvolution.DeconvUtil.normalizepdf</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">normalizepdf(array...; warn=true)
normalizepdf!(array...; warn=true)</code></pre><p>Normalize each array to a discrete probability density function.</p><p>By default, <code>warn</code> if coping with NaNs, Infs, or negative values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mirkobunse/CherenkovDeconvolution.jl/blob/71dc855f841469b3438695912d46fe3f82b80784/src/DeconvUtil.jl#L118-L125">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CherenkovDeconvolution.DeconvUtil.normalizepdf!" href="#CherenkovDeconvolution.DeconvUtil.normalizepdf!"><code>CherenkovDeconvolution.DeconvUtil.normalizepdf!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">normalizepdf(array...; warn=true)
normalizepdf!(array...; warn=true)</code></pre><p>Normalize each array to a discrete probability density function.</p><p>By default, <code>warn</code> if coping with NaNs, Infs, or negative values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mirkobunse/CherenkovDeconvolution.jl/blob/71dc855f841469b3438695912d46fe3f82b80784/src/DeconvUtil.jl#L119-L126">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CherenkovDeconvolution.DeconvUtil.polynomial_smoothing" href="#CherenkovDeconvolution.DeconvUtil.polynomial_smoothing"><code>CherenkovDeconvolution.DeconvUtil.polynomial_smoothing</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">polynomial_smoothing([o = 2, warn = true])</code></pre><p>Create a function object <code>f -&gt; smoothing(f)</code> which smoothes its argument with a polynomial of order <code>o</code>. <code>warn</code> specifies if a warning is emitted when negative values returned by the smoothing are replaced by the average of neighboring values - a post-processing step proposed in [dagostini2010improved].</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mirkobunse/CherenkovDeconvolution.jl/blob/71dc855f841469b3438695912d46fe3f82b80784/src/DeconvUtil.jl#L237-L244">source</a></section></article><h2 id="Developer-interface"><a class="docs-heading-anchor" href="#Developer-interface">Developer interface</a><a id="Developer-interface-1"></a><a class="docs-heading-anchor-permalink" href="#Developer-interface" title="Permalink"></a></h2><p>The following list of methods is primarily intended for developers who wish to implement their own deconvolution methods, binnings, stepsizes, etc. If you do so, please file a pull request so that others can benefit from your work! More information on how to develop for this package is given in the <a href="../developer-manual/#Developer-manual">Developer manual</a>.</p><article class="docstring"><header><a class="docstring-binding" id="CherenkovDeconvolution.Methods.DeconvolutionMethod" href="#CherenkovDeconvolution.Methods.DeconvolutionMethod"><code>CherenkovDeconvolution.Methods.DeconvolutionMethod</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">abstract type DeconvolutionMethod</code></pre><p>The supertype of all deconvolution methods.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mirkobunse/CherenkovDeconvolution.jl/blob/71dc855f841469b3438695912d46fe3f82b80784/src/Methods.jl#L47-L51">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CherenkovDeconvolution.Methods.DiscreteMethod" href="#CherenkovDeconvolution.Methods.DiscreteMethod"><code>CherenkovDeconvolution.Methods.DiscreteMethod</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">abstract type DiscreteMethod &lt;: DeconvolutionMethod</code></pre><p>The supertype of all classical deconvolution methods which estimate the density function <code>f</code> from a transfer matrix <code>R</code> and an observed density <code>g</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mirkobunse/CherenkovDeconvolution.jl/blob/71dc855f841469b3438695912d46fe3f82b80784/src/Methods.jl#L54-L59">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CherenkovDeconvolution.Binnings.Binning" href="#CherenkovDeconvolution.Binnings.Binning"><code>CherenkovDeconvolution.Binnings.Binning</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">abstract type Binning</code></pre><p>Supertype of all binning strategies for observable features.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mirkobunse/CherenkovDeconvolution.jl/blob/71dc855f841469b3438695912d46fe3f82b80784/src/Binnings.jl#L42-L46">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CherenkovDeconvolution.Binnings.BinningDiscretizer" href="#CherenkovDeconvolution.Binnings.BinningDiscretizer"><code>CherenkovDeconvolution.Binnings.BinningDiscretizer</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">abstract type BinningDiscretizer &lt;: AbstractDiscretizer</code></pre><p>Supertype of any clustering-based discretizer mapping from an n-dimensional space to a single cluster index dimension.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mirkobunse/CherenkovDeconvolution.jl/blob/71dc855f841469b3438695912d46fe3f82b80784/src/Binnings.jl#L84-L89">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CherenkovDeconvolution.Binnings.bins" href="#CherenkovDeconvolution.Binnings.bins"><code>CherenkovDeconvolution.Binnings.bins</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">bins(d::T) where T &lt;: BinningDiscretizer</code></pre><p>Return the bin indices of <code>d</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mirkobunse/CherenkovDeconvolution.jl/blob/71dc855f841469b3438695912d46fe3f82b80784/src/Binnings.jl#L166-L170">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Discretizers.encode" href="#Discretizers.encode"><code>Discretizers.encode</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">encode(d::TreeDiscretizer, X_obs)</code></pre><p>Discretize <code>X_obs</code> using the leaf indices in the decision tree of <code>d</code> as discrete values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mirkobunse/CherenkovDeconvolution.jl/blob/71dc855f841469b3438695912d46fe3f82b80784/src/Binnings.jl#L122-L126">source</a></section><section><div><pre><code class="language-none">encode(d::KMeansDiscretizer, X_obs)</code></pre><p>Discretize <code>X_obs</code> using the cluster indices of <code>d</code> as discrete values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mirkobunse/CherenkovDeconvolution.jl/blob/71dc855f841469b3438695912d46fe3f82b80784/src/Binnings.jl#L156-L160">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CherenkovDeconvolution.Stepsizes.Stepsize" href="#CherenkovDeconvolution.Stepsizes.Stepsize"><code>CherenkovDeconvolution.Stepsizes.Stepsize</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">abstract type stepsize end</code></pre><p>Abstract supertype for step sizes in deconvolution.</p><p><strong>See also:</strong> <code>stepsize</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mirkobunse/CherenkovDeconvolution.jl/blob/71dc855f841469b3438695912d46fe3f82b80784/src/Stepsizes.jl#L42-L48">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CherenkovDeconvolution.OptimizedStepsizes.OptimizedStepsize" href="#CherenkovDeconvolution.OptimizedStepsizes.OptimizedStepsize"><code>CherenkovDeconvolution.OptimizedStepsizes.OptimizedStepsize</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">OptimizedStepsize(objective, decay)</code></pre><p>A step size that is optimized over an <code>objective</code> function. If <code>decay=true</code>, then the step sizes never increase.</p><p><strong>See also:</strong> <code>RunStepsize</code>, <code>LsqStepsize</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mirkobunse/CherenkovDeconvolution.jl/blob/71dc855f841469b3438695912d46fe3f82b80784/src/OptimizedStepsizes.jl#L35-L42">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CherenkovDeconvolution.Stepsizes.initialize!" href="#CherenkovDeconvolution.Stepsizes.initialize!"><code>CherenkovDeconvolution.Stepsizes.initialize!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">initialize!(s, X_obs, X_trn, y_trn)</code></pre><p>Prepare the stepsize strategy <code>s</code> with the observed features in <code>X_obs</code> and the training set <code>(X_trn, y_trn)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mirkobunse/CherenkovDeconvolution.jl/blob/71dc855f841469b3438695912d46fe3f82b80784/src/Stepsizes.jl#L63-L68">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CherenkovDeconvolution.Stepsizes.value" href="#CherenkovDeconvolution.Stepsizes.value"><code>CherenkovDeconvolution.Stepsizes.value</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">value(s, k, p, f, a)</code></pre><p>Use the <code>Stepsize</code> object <code>s</code> to compute a step size for iteration number <code>k</code> with the search direction <code>p</code>, the previous estimate <code>f</code>, and the previous step size <code>a</code>.</p><p><strong>See also:</strong> <code>ConstantStepsize</code>, <code>RunStepsize</code>, <code>LsqStepsize</code>, <code>ExpDecayStepsize</code>, <code>MulDecayStepsize</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mirkobunse/CherenkovDeconvolution.jl/blob/71dc855f841469b3438695912d46fe3f82b80784/src/Stepsizes.jl#L51-L59">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CherenkovDeconvolution.Methods.check_prior" href="#CherenkovDeconvolution.Methods.check_prior"><code>CherenkovDeconvolution.Methods.check_prior</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">check_prior(f_0, n_bins)</code></pre><p>Throw meaningful exceptions if the input prior of a deconvolution run is defective.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mirkobunse/CherenkovDeconvolution.jl/blob/71dc855f841469b3438695912d46fe3f82b80784/src/Methods.jl#L214-L218">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CherenkovDeconvolution.Methods.check_arguments" href="#CherenkovDeconvolution.Methods.check_arguments"><code>CherenkovDeconvolution.Methods.check_arguments</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">check_arguments(X_obs, X_trn, y_trn)</code></pre><p>Throw meaningful exceptions if the input data of a deconvolution run is defective.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mirkobunse/CherenkovDeconvolution.jl/blob/71dc855f841469b3438695912d46fe3f82b80784/src/Methods.jl#L186-L190">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CherenkovDeconvolution.Methods.LoneClassException" href="#CherenkovDeconvolution.Methods.LoneClassException"><code>CherenkovDeconvolution.Methods.LoneClassException</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">LoneClassException(label)</code></pre><p>An exception thrown by <code>check_arguments</code> when only one class is in the training set.</p><p><strong>See also:</strong> <code>recover_estimate</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mirkobunse/CherenkovDeconvolution.jl/blob/71dc855f841469b3438695912d46fe3f82b80784/src/Methods.jl#L161-L167">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CherenkovDeconvolution.Methods.recover_estimate" href="#CherenkovDeconvolution.Methods.recover_estimate"><code>CherenkovDeconvolution.Methods.recover_estimate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">recover_estimate(x::LoneClassException, n_bins=1)</code></pre><p>Recover a trivial deconvolution result from <code>x</code>, in which all bins are zero, except for the one that occured in the training set.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mirkobunse/CherenkovDeconvolution.jl/blob/71dc855f841469b3438695912d46fe3f82b80784/src/Methods.jl#L174-L179">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CherenkovDeconvolution.Methods.LabelSanitizer" href="#CherenkovDeconvolution.Methods.LabelSanitizer"><code>CherenkovDeconvolution.Methods.LabelSanitizer</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">LabelSanitizer(y_trn, n_bins=maximum(y_trn))</code></pre><p>A sanitizer that</p><ul><li>encodes labels and priors so that none of the resulting bins is empty.</li><li>decodes deconvolution results to recover the original (possibly empty) bins.</li></ul><p><strong>See also:</strong> <code>encode_labels</code>, <code>encode_prior</code>, <code>decode_estimate</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mirkobunse/CherenkovDeconvolution.jl/blob/71dc855f841469b3438695912d46fe3f82b80784/src/Methods.jl#L62-L71">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CherenkovDeconvolution.Methods.encode_labels" href="#CherenkovDeconvolution.Methods.encode_labels"><code>CherenkovDeconvolution.Methods.encode_labels</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">encode_labels(s::LabelSanitizer, y_trn)</code></pre><p>Encode the labels <code>y_trn</code> so that all values from <code>1</code> to <code>max(y_trn)</code> occur.</p><p><strong>See also:</strong> <code>encode_prior</code>, <code>decode_estimate</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mirkobunse/CherenkovDeconvolution.jl/blob/71dc855f841469b3438695912d46fe3f82b80784/src/Methods.jl#L224-L230">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CherenkovDeconvolution.Methods.encode_prior" href="#CherenkovDeconvolution.Methods.encode_prior"><code>CherenkovDeconvolution.Methods.encode_prior</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">encode_prior(s::LabelSanitizer, f_0)</code></pre><p>Encode the prior <code>f_0</code> to be consistent with the encoded labels.</p><p><strong>See also:</strong> <code>encode_labels</code>, <code>decode_estimate</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mirkobunse/CherenkovDeconvolution.jl/blob/71dc855f841469b3438695912d46fe3f82b80784/src/Methods.jl#L236-L242">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CherenkovDeconvolution.Methods.decode_estimate" href="#CherenkovDeconvolution.Methods.decode_estimate"><code>CherenkovDeconvolution.Methods.decode_estimate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">decode_estimate(s::LabelSanitizer, f)</code></pre><p>Recover the original bins in a deconvolution result <code>f</code> after encoding the labels.</p><p><strong>See also:</strong> <code>encode_labels</code>, <code>encode_prior</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mirkobunse/CherenkovDeconvolution.jl/blob/71dc855f841469b3438695912d46fe3f82b80784/src/Methods.jl#L245-L251">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../python-wrapper/">« Python wrapper</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Wednesday 24 November 2021 09:43">Wednesday 24 November 2021</span>. Using Julia version 1.6.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
